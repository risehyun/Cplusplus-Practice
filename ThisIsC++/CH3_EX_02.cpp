#include <stdio.h>

// 제작자의 코드
typedef struct USERDATA
{
	int nAge;
	char szName[32];

}USERDATA;

/* 

제작자가 사용자가 정의한 data를 출력할 수 있는 함수를 제공함.
이를 통해 사용자는 데이터 출력을 위한 구체적인 방법을 굳이 알 필요 없이 그냥 값을 &로 넘겨주면 기능을 작동시킬 수 있게 됨.
이와 같은 역할을 수행하는 함수를 '인터페이스 함수'라고 한다.

이러한 인터페이스 함수는 마치 자동차를 운전하는 것과 같다.
모든 자동차에는 핸들, 브레이크, 엑셀러레이터 같은 보편적 인터페이스들이 존재한다.
사용자는 자동차의 모델이 변경된다고 해도 이 인터페이스를 사용해 어떤 차든 원래 하던 방식대로 운전을 할 수 있다.


 */
 void PrintData(USERDATA* pUser)
{
	printf("%d, %s\n", pUser->nAge, pUser->szName);
}

// 사용자의 코드
int main(void)
{
	USERDATA user = { 20, "철수" };
	// printf("%d, %s\n", user.nAge, user.szName);
	PrintData(&user);

	return 0;
}

/*

그런데 이 예제처럼 인터페이스 함수를 제공하더라도 한 가지 문제가 발생한다.
자료구조와 함수가 각각 따로 존재할 뿐, 그 둘의 관계를 엮어서 하나로 묶어주지는 못한다.
따라서 각 구조체와 함수가 무슨 관계에 있는지는 코드만 봐서는 알 수 없게 된다.

이를 해결하기 위해 등장한 개념이 바로 구조체 안에 함수를 집어 넣어버리는 것이다.
관련 내용은 다음 예제에서 계속된다.

*/